
local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

local Window = Rayfield:CreateWindow({
    Name = "Universal Script | Made By Sudais",
    LoadingTitle = "LatestVersion",
    LoadingSubtitle = "by SUDAISxCHEATS",
    ConfigurationSaving = {
       Enabled = true,
       FolderName = nil, -- Create a custom folder for your hub/game
       FileName = "Big Hub"
    },
    Discord = {
       Enabled = false,
       Invite = "noinvitelink", -- The Discord invite code, do not include discord.gg/. E.g. discord.gg/ABCD would be ABCD
       RememberJoins = true -- Set this to false to make them join the discord every time they load it up
    },
    KeySystem = false, -- Set this to true to use our key system
    KeySettings = {
       Title = "Untitled",
       Subtitle = "Key System",
       Note = "No method of obtaining the key is provided",
       FileName = "Key", -- It is recommended to use something unique as other scripts using Rayfield may overwrite your key file
       SaveKey = true, -- The user's key will be saved, but if you change the key, they will be unable to use your script
       GrabKeyFromSite = false, -- If this is true, set Key below to the RAW site you would like Rayfield to get the key from
       Key = {"Hello"} -- List of keys that will be accepted by the system, can be RAW file links (pastebin, github etc) or simple strings ("hello","key22")
    }
 })

 local PlayerTab = Window:CreateTab("Player", 4483362458)
local Button = PlayerTab:CreateButton({
   Name = "AimBot(Activation Key E)",
   Callback = function()
   -- This script should be placed in a LocalScript within a Player's Character
-- It requires a Humanoid object and a Head part in the character.

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local Humanoid = Character:WaitForChild("Humanoid")
local Head = Character:WaitForChild("Head")

-- Configuration
local ACTIVATION_KEY = Enum.KeyCode.E -- Key to toggle aimbot (change as desired)
local AIM_SENSITIVITY = 0.1 -- Adjust for smoother/faster aiming
local AIM_RANGE = 100 -- Maximum distance to consider targets
local RAYCAST_PARAMS = RaycastParams.new()
RAYCAST_PARAMS.FilterType = Enum.RaycastFilterType.Blacklist
RAYCAST_PARAMS.FilterDescendantsInstances = {Character} -- Don't hit self

local aiming = false
local currentTarget = nil

-- Function to get the closest living humanoid within range
local function getClosestTarget()
    local closestDistance = AIM_RANGE
    local closestHumanoid = nil
    local cameraPosition = workspace.CurrentCamera.CFrame.Position

    for _, player in Players:GetPlayers() do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") and player.Character:FindFirstChild("Humanoid") and player.Character.Humanoid.Health > 0 then
            local targetHumanoidRootPart = player.Character.HumanoidRootPart
            local distance = (targetHumanoidRootPart.Position - cameraPosition).Magnitude

            if distance < closestDistance then
                closestDistance = distance
                closestHumanoid = player.Character:FindFirstChild("Humanoid")
            end
        end
    end
    return closestHumanoid
end

-- Function to calculate the head position with potential offset
local function getHeadPosition(humanoid)
    local head = humanoid.Parent:FindFirstChild("Head")
    if head then
        -- You might want to add a small upward offset here if the aim is slightly too low
        return head.CFrame.Position -- + Vector3.new(0, 0.2, 0)
    end
    return nil
end

-- Function to smoothly rotate the camera towards a target position
local function aimTowards(targetPosition)
    local camera = workspace.CurrentCamera
    local currentLookVector = camera.CFrame.LookVector
    local directionToTarget = (targetPosition - camera.CFrame.Position).Unit

    -- Calculate the rotation needed to face the target
    local rotationAxis = currentLookVector:Cross(directionToTarget).Unit
    local rotationAngle = math.acos(math.clamp(currentLookVector:Dot(directionToTarget), -1, 1))

    -- Apply a small increment of the rotation for smooth aiming
    local limitedAngle = rotationAngle * AIM_SENSITIVITY
    local rotationCFrame = CFrame.fromAxisAngle(rotationAxis, limitedAngle)

    camera.CFrame = camera.CFrame * rotationCFrame
end

-- Function to handle aiming logic
local function updateAim()
    if aiming then
        local targetHumanoid = getClosestTarget()
        if targetHumanoid then
            currentTarget = targetHumanoid
            local targetHeadPosition = getHeadPosition(targetHumanoid)
            if targetHeadPosition then
                aimTowards(targetHeadPosition)
            else
                currentTarget = nil -- Target head not found
            end
        else
            currentTarget = nil -- No target in range
        end
    end
end

-- Input handling to toggle aiming
local UserInputService = game:GetService("UserInputService")
UserInputService.InputBegan:Connect(function(input, gameProcessedEvent)
    if not gameProcessedEvent and input.KeyCode == ACTIVATION_KEY then
        aiming = not aiming
        if aiming then
            print("Aimbot enabled")
        else
            print("Aimbot disabled")
            currentTarget = nil
        end
    end
end)

-- Run the aiming logic every frame
RunService.RenderStepped:Connect(updateAim)
   -- The function that takes place when the button is pressed
   end,
})
local Button = PlayerTab:CreateButton({
   Name = "Box Esp",
   Callback = function()
   --[[
	WARNING: Heads up! This script has not been verified by ScriptBlox. Use at your own risk!
]]
while wait(0.5) do
    for i, box in ipairs(workspace:GetDescendants()) do
        if box:FindFirstChild("Humanoid") then
            if not box:FindFirstChild("EspBox") then
                if box ~= game.Players.LocalPlayer.Character then
                    local esp = Instance.new("BoxHandleAdornment",box)
                    esp.Adornee = box
                    esp.ZIndex = 0
                    esp.Size = Vector3.new(5, 6, 2)
                    esp.Transparency = 0.5 --Changes Transparency 
                    esp.Color3 = Color3.fromRGB(0,255,0) --Color change
                    esp.AlwaysOnTop = true
                    esp.Name = "EspBox"
                end
            end
        end
    end
end
   -- The function that takes place when the button is pressed
   end,
})
local Button = PlayerTab:CreateButton({
   Name = "Name ESP",
   Callback = function()
   local Players = game:GetService("Players")

local function onCharacterAdded(character)
    local humanoid = character:WaitForChild("Humanoid")
    if not humanoid then return end

    local head = character:WaitForChild("Head")
    if not head then return end

    -- Create a BillboardGui
    local billboardGui = Instance.new("BillboardGui")
    billboardGui.Name = "UsernameDisplay"
    billboardGui.Adornee = head
    billboardGui.Size = UDim2.new(0, 100, 0, 20) -- Adjust size as needed
    billboardGui.AlwaysOnTop = true
    billboardGui.StudsOffset = Vector3.new(0, 2, 0) -- Adjust vertical offset

    -- Create a TextLabel within the BillboardGui
    local textLabel = Instance.new("TextLabel")
    textLabel.Name = "UsernameLabel"
    textLabel.Size = UDim2.new(1, 0, 1, 0)
    textLabel.BackgroundTransparency = 1
    textLabel.TextScaled = true
    textLabel.TextColor3 = Color3.new(1, 1, 1) -- White text
    textLabel.Font = Enum.Font.SourceSansBold -- Or your preferred font
    textLabel.TextStrokeColor3 = Color3.new(0, 0, 0) -- Black outline
    textLabel.TextStrokeTransparency = 0
    textLabel.Text = character.Name -- Set initial username
    textLabel.Parent = billboardGui

    billboardGui.Parent = head
end

local function onPlayerAdded(player)
    player.CharacterAdded:Connect(onCharacterAdded)
    if player.Character then
        onCharacterAdded(player.Character)
    end
end

-- Connect to existing players
for _, player in Players:GetPlayers() do
    onPlayerAdded(player)
end

-- Connect to new players joining
Players.PlayerAdded:Connect(onPlayerAdded)

-- Optional: Handle character respawning
Players.PlayerRemoving:Connect(function(player)
    if player and player.Character then
        for _, object in pairs(player.Character:GetChildren()) do
            if object:IsA("BillboardGui") and object.Name == "UsernameDisplay" then
                object:Destroy()
            end
        end
    end
end)
   -- The function that takes place when the button is pressed
   end,
})
local Button = PlayerTab:CreateButton({
   Name = "CrossHair ESP",
   Callback = function()
   -- This script should be placed in a LocalScript within StarterPlayerScripts

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local UserInputService = game:GetService("UserInputService")

-- Configuration
local CROSSHAIR_COLOR = Color3.new(1, 0, 0) -- Red color for the crosshair
local CROSSHAIR_THICKNESS = 2 -- Thickness of the crosshair lines in pixels
local CROSSHAIR_LENGTH = 15 -- Length of each crosshair line in pixels
local CROSSHAIR_OFFSET = 5 -- Space between the center and the start of the lines

local screenGui = Instance.new("ScreenGui")
screenGui.Name = "PlayerCrosshairs"
screenGui.IgnoreGuiInset = true
screenGui.Parent = LocalPlayer.PlayerGui

local playerCrosshairs = {} -- Table to store crosshair frames for each player

local function createCrosshair(player)
    if player == LocalPlayer then return end -- Don't draw a crosshair on yourself

    local character = player.Character
    if not character or not character:FindFirstChild("Head") then return end

    local head = character:FindFirstChild("Head")

    local billboardGui = Instance.new("BillboardGui")
    billboardGui.Name = "CrosshairGUI"
    billboardGui.Adornee = head
    billboardGui.Size = UDim2.new(0, 50, 0, 50) -- Adjust size as needed
    billboardGui.AlwaysOnTop = true
    billboardGui.StudsOffset = Vector3.new(0, 2, 0) -- Adjust vertical offset

    local centerFrame = Instance.new("Frame")
    centerFrame.Size = UDim2.new(0, 1, 0, 1)
    centerFrame.BackgroundTransparency = 1
    centerFrame.Position = UDim2.new(0.5, -0.5, 0.5, -0.5)
    centerFrame.AnchorPoint = Vector2.new(0.5, 0.5)
    centerFrame.Parent = billboardGui

    -- Create the four lines of the crosshair
    local function createLine(x, y, width, height)
        local line = Instance.new("Frame")
        line.BackgroundColor3 = CROSSHAIR_COLOR
        line.BorderSizePixel = 0
        line.Size = UDim2.new(0, width, 0, height)
        line.Position = UDim2.new(0.5, -width / 2, 0.5, -height / 2)
        line.AnchorPoint = Vector2.new(0.5, 0.5)
        line.Parent = centerFrame
        return line
    end

    createLine(CROSSHAIR_LENGTH + CROSSHAIR_OFFSET, CROSSHAIR_THICKNESS, CROSSHAIR_LENGTH * 2 + CROSSHAIR_OFFSET * 2, CROSSHAIR_THICKNESS) -- Horizontal
    createLine(CROSSHAIR_THICKNESS, CROSSHAIR_LENGTH + CROSSHAIR_OFFSET, CROSSHAIR_THICKNESS, CROSSHAIR_LENGTH * 2 + CROSSHAIR_OFFSET * 2) -- Vertical

    billboardGui.Parent = head
    playerCrosshairs[player] = billboardGui
end

local function onPlayerAdded(player)
    player.CharacterAdded:Connect(function(character)
        -- Wait a short time to ensure the head is loaded
        wait(0.5)
        createCrosshair(player)
    end)
    if player.Character then
        -- Wait a short time to ensure the head is loaded
        wait(0.5)
        createCrosshair(player)
    end
end

local function onPlayerRemoving(player)
    if playerCrosshairs[player] then
        playerCrosshairs[player]:Destroy()
        playerCrosshairs[player] = nil
    end
end

-- Initial setup for existing players
for _, player in Players:GetPlayers() do
    onPlayerAdded(player)
end

-- Handle new players joining
Players.PlayerAdded:Connect(onPlayerAdded)

-- Handle players leaving
Players.PlayerRemoving:Connect(onPlayerRemoving)
   -- The function that takes place when the button is pressed
   end,
})
 local Slider = PlayerTab:CreateSlider({
    Name = "WalkSpeed",
    Range = {1, 300},
    Increment = 1,
    Suffix = "Speed",
    CurrentValue = 16,
    Flag = "Slider1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value)
     game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = Value
    end,
 })



 local Slider = PlayerTab:CreateSlider({
    Name = "Jump Height",
    Range = {10, 500},
    Increment = 1,
    Suffix = "Height",
    CurrentValue = 10,
    Flag = "Slider3", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value)
     game.Players.LocalPlayer.Character.Humanoid.JumpPower = Value
    end,
 })
 local Button = PlayerTab:CreateButton({
   Name = "FlyGUi",
   Callback = function()
   -- Instances:

local main = Instance.new("ScreenGui")
local Frame = Instance.new("Frame")
local up = Instance.new("TextButton")
local down = Instance.new("TextButton")
local onof = Instance.new("TextButton")
local TextLabel = Instance.new("TextLabel")
local plus = Instance.new("TextButton")
local speed = Instance.new("TextLabel")
local mine = Instance.new("TextButton")

--Properties:

main.Name = "main"
main.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")
main.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

Frame.Parent = main
Frame.BackgroundColor3 = Color3.fromRGB(163, 255, 137)
Frame.BorderColor3 = Color3.fromRGB(103, 221, 213)
Frame.Position = UDim2.new(0.100320168, 0, 0.379746825, 0)
Frame.Size = UDim2.new(0, 190, 0, 57)

up.Name = "up"
up.Parent = Frame
up.BackgroundColor3 = Color3.fromRGB(79, 255, 152)
up.Size = UDim2.new(0, 44, 0, 28)
up.Font = Enum.Font.SourceSans
up.Text = "UP"
up.TextColor3 = Color3.fromRGB(0, 0, 0)
up.TextSize = 14.000

down.Name = "down"
down.Parent = Frame
down.BackgroundColor3 = Color3.fromRGB(215, 255, 121)
down.Position = UDim2.new(0, 0, 0.491228074, 0)
down.Size = UDim2.new(0, 44, 0, 28)
down.Font = Enum.Font.SourceSans
down.Text = "DOWN"
down.TextColor3 = Color3.fromRGB(0, 0, 0)
down.TextSize = 14.000

onof.Name = "onof"
onof.Parent = Frame
onof.BackgroundColor3 = Color3.fromRGB(255, 249, 74)
onof.Position = UDim2.new(0.702823281, 0, 0.491228074, 0)
onof.Size = UDim2.new(0, 56, 0, 28)
onof.Font = Enum.Font.SourceSans
onof.Text = "fly"
onof.TextColor3 = Color3.fromRGB(0, 0, 0)
onof.TextSize = 14.000

TextLabel.Parent = Frame
TextLabel.BackgroundColor3 = Color3.fromRGB(242, 60, 255)
TextLabel.Position = UDim2.new(0.469327301, 0, 0, 0)
TextLabel.Size = UDim2.new(0, 100, 0, 28)
TextLabel.Font = Enum.Font.SourceSans
TextLabel.Text = "gui by SudaisXCheats"
TextLabel.TextColor3 = Color3.fromRGB(0, 0, 0)
TextLabel.TextScaled = true
TextLabel.TextSize = 14.000
TextLabel.TextWrapped = true

plus.Name = "plus"
plus.Parent = Frame
plus.BackgroundColor3 = Color3.fromRGB(133, 145, 255)
plus.Position = UDim2.new(0.231578946, 0, 0, 0)
plus.Size = UDim2.new(0, 45, 0, 28)
plus.Font = Enum.Font.SourceSans
plus.Text = "+"
plus.TextColor3 = Color3.fromRGB(0, 0, 0)
plus.TextScaled = true
plus.TextSize = 14.000
plus.TextWrapped = true

speed.Name = "speed"
speed.Parent = Frame
speed.BackgroundColor3 = Color3.fromRGB(255, 85, 0)
speed.Position = UDim2.new(0.468421042, 0, 0.491228074, 0)
speed.Size = UDim2.new(0, 44, 0, 28)
speed.Font = Enum.Font.SourceSans
speed.Text = "1"
speed.TextColor3 = Color3.fromRGB(0, 0, 0)
speed.TextScaled = true
speed.TextSize = 14.000
speed.TextWrapped = true

mine.Name = "mine"
mine.Parent = Frame
mine.BackgroundColor3 = Color3.fromRGB(123, 255, 247)
mine.Position = UDim2.new(0.231578946, 0, 0.491228074, 0)
mine.Size = UDim2.new(0, 45, 0, 29)
mine.Font = Enum.Font.SourceSans
mine.Text = "-"
mine.TextColor3 = Color3.fromRGB(0, 0, 0)
mine.TextScaled = true
mine.TextSize = 14.000
mine.TextWrapped = true

speeds = 1

local speaker = game:GetService("Players").LocalPlayer

local chr = game.Players.LocalPlayer.Character
local hum = chr and chr:FindFirstChildWhichIsA("Humanoid")

nowe = false

game:GetService("StarterGui"):SetCore("SendNotification", { 
    Title = "GO SUB TO HIM";
    Text = "fly gui by SudaisXCheats";
    Icon = "rbxthumb://type=Asset&id=5107182114&w=150&h=150"})
Duration = 16;

Frame.Active = true -- main = gui
Frame.Draggable = true

onof.MouseButton1Down:connect(function()

    if nowe == true then
        nowe = false

        speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.Climbing,true)
        speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.FallingDown,true)
        speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.Flying,true)
        speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.Freefall,true)
        speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.GettingUp,true)
        speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.Jumping,true)
        speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.Landed,true)
        speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.Physics,true)
        speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.PlatformStanding,true)
        speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.Ragdoll,true)
        speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.Running,true)
        speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.RunningNoPhysics,true)
        speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated,true)
        speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.StrafingNoPhysics,true)
        speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.Swimming,true)
        speaker.Character.Humanoid:ChangeState(Enum.HumanoidStateType.RunningNoPhysics)
    else 
        nowe = true



        for i = 1, speeds do
            spawn(function()

                local hb = game:GetService("RunService").Heartbeat


                tpwalking = true
                local chr = game.Players.LocalPlayer.Character
                local hum = chr and chr:FindFirstChildWhichIsA("Humanoid")
                while tpwalking and hb:Wait() and chr and hum and hum.Parent do
                    if hum.MoveDirection.Magnitude > 0 then
                        chr:TranslateBy(hum.MoveDirection)
                    end
                end

            end)
        end
        game.Players.LocalPlayer.Character.Animate.Disabled = true
        local Char = game.Players.LocalPlayer.Character
        local Hum = Char:FindFirstChildOfClass("Humanoid") or Char:FindFirstChildOfClass("AnimationController")

        for i,v in next, Hum:GetPlayingAnimationTracks() do
            v:AdjustSpeed(0)
        end
        speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.Climbing,false)
        speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.FallingDown,false)
        speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.Flying,false)
        speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.Freefall,false)
        speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.GettingUp,false)
        speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.Jumping,false)
        speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.Landed,false)
        speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.Physics,false)
        speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.PlatformStanding,false)
        speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.Ragdoll,false)
        speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.Running,false)
        speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.RunningNoPhysics,false)
        speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated,false)
        speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.StrafingNoPhysics,false)
        speaker.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.Swimming,false)
        speaker.Character.Humanoid:ChangeState(Enum.HumanoidStateType.Swimming)
    end




    if game:GetService("Players").LocalPlayer.Character:FindFirstChildOfClass("Humanoid").RigType == Enum.HumanoidRigType.R6 then



        local plr = game.Players.LocalPlayer
        local torso = plr.Character.Torso
        local flying = true
        local deb = true
        local ctrl = {f = 0, b = 0, l = 0, r = 0}
        local lastctrl = {f = 0, b = 0, l = 0, r = 0}
        local maxspeed = 50
        local speed = 0


        local bg = Instance.new("BodyGyro", torso)
        bg.P = 9e4
        bg.maxTorque = Vector3.new(9e9, 9e9, 9e9)
        bg.cframe = torso.CFrame
        local bv = Instance.new("BodyVelocity", torso)
        bv.velocity = Vector3.new(0,0.1,0)
        bv.maxForce = Vector3.new(9e9, 9e9, 9e9)
        if nowe == true then
            plr.Character.Humanoid.PlatformStand = true
        end
        while nowe == true or game:GetService("Players").LocalPlayer.Character.Humanoid.Health == 0 do
            game:GetService("RunService").RenderStepped:Wait()

            if ctrl.l + ctrl.r ~= 0 or ctrl.f + ctrl.b ~= 0 then
                speed = speed+.5+(speed/maxspeed)
                if speed > maxspeed then
                    speed = maxspeed
                end
            elseif not (ctrl.l + ctrl.r ~= 0 or ctrl.f + ctrl.b ~= 0) and speed ~= 0 then
                speed = speed-1
                if speed < 0 then
                    speed = 0
                end
            end
            if (ctrl.l + ctrl.r) ~= 0 or (ctrl.f + ctrl.b) ~= 0 then
                bv.velocity = ((game.Workspace.CurrentCamera.CoordinateFrame.lookVector * (ctrl.f+ctrl.b)) + ((game.Workspace.CurrentCamera.CoordinateFrame * CFrame.new(ctrl.l+ctrl.r,(ctrl.f+ctrl.b)*.2,0).p) - game.Workspace.CurrentCamera.CoordinateFrame.p))*speed
                lastctrl = {f = ctrl.f, b = ctrl.b, l = ctrl.l, r = ctrl.r}
            elseif (ctrl.l + ctrl.r) == 0 and (ctrl.f + ctrl.b) == 0 and speed ~= 0 then
                bv.velocity = ((game.Workspace.CurrentCamera.CoordinateFrame.lookVector * (lastctrl.f+lastctrl.b)) + ((game.Workspace.CurrentCamera.CoordinateFrame * CFrame.new(lastctrl.l+lastctrl.r,(lastctrl.f+lastctrl.b)*.2,0).p) - game.Workspace.CurrentCamera.CoordinateFrame.p))*speed
            else
                bv.velocity = Vector3.new(0,0,0)
            end
            --  game.Players.LocalPlayer.Character.Animate.Disabled = true
            bg.cframe = game.Workspace.CurrentCamera.CoordinateFrame * CFrame.Angles(-math.rad((ctrl.f+ctrl.b)*50*speed/maxspeed),0,0)
        end
        ctrl = {f = 0, b = 0, l = 0, r = 0}
        lastctrl = {f = 0, b = 0, l = 0, r = 0}
        speed = 0
        bg:Destroy()
        bv:Destroy()
        plr.Character.Humanoid.PlatformStand = false
        game.Players.LocalPlayer.Character.Animate.Disabled = false
        tpwalking = false




    else
        local plr = game.Players.LocalPlayer
        local UpperTorso = plr.Character.UpperTorso
        local flying = true
        local deb = true
        local ctrl = {f = 0, b = 0, l = 0, r = 0}
        local lastctrl = {f = 0, b = 0, l = 0, r = 0}
        local maxspeed = 50
        local speed = 0


        local bg = Instance.new("BodyGyro", UpperTorso)
        bg.P = 9e4
        bg.maxTorque = Vector3.new(9e9, 9e9, 9e9)
        bg.cframe = UpperTorso.CFrame
        local bv = Instance.new("BodyVelocity", UpperTorso)
        bv.velocity = Vector3.new(0,0.1,0)
        bv.maxForce = Vector3.new(9e9, 9e9, 9e9)
        if nowe == true then
            plr.Character.Humanoid.PlatformStand = true
        end
        while nowe == true or game:GetService("Players").LocalPlayer.Character.Humanoid.Health == 0 do
            wait()

            if ctrl.l + ctrl.r ~= 0 or ctrl.f + ctrl.b ~= 0 then
                speed = speed+.5+(speed/maxspeed)
                if speed > maxspeed then
                    speed = maxspeed
                end
            elseif not (ctrl.l + ctrl.r ~= 0 or ctrl.f + ctrl.b ~= 0) and speed ~= 0 then
                speed = speed-1
                if speed < 0 then
                    speed = 0
                end
            end
            if (ctrl.l + ctrl.r) ~= 0 or (ctrl.f + ctrl.b) ~= 0 then
                bv.velocity = ((game.Workspace.CurrentCamera.CoordinateFrame.lookVector * (ctrl.f+ctrl.b)) + ((game.Workspace.CurrentCamera.CoordinateFrame * CFrame.new(ctrl.l+ctrl.r,(ctrl.f+ctrl.b)*.2,0).p) - game.Workspace.CurrentCamera.CoordinateFrame.p))*speed
                lastctrl = {f = ctrl.f, b = ctrl.b, l = ctrl.l, r = ctrl.r}
            elseif (ctrl.l + ctrl.r) == 0 and (ctrl.f + ctrl.b) == 0 and speed ~= 0 then
                bv.velocity = ((game.Workspace.CurrentCamera.CoordinateFrame.lookVector * (lastctrl.f+lastctrl.b)) + ((game.Workspace.CurrentCamera.CoordinateFrame * CFrame.new(lastctrl.l+lastctrl.r,(lastctrl.f+lastctrl.b)*.2,0).p) - game.Workspace.CurrentCamera.CoordinateFrame.p))*speed
            else
                bv.velocity = Vector3.new(0,0,0)
            end

            bg.cframe = game.Workspace.CurrentCamera.CoordinateFrame * CFrame.Angles(-math.rad((ctrl.f+ctrl.b)*50*speed/maxspeed),0,0)
        end
        ctrl = {f = 0, b = 0, l = 0, r = 0}
        lastctrl = {f = 0, b = 0, l = 0, r = 0}
        speed = 0
        bg:Destroy()
        bv:Destroy()
        plr.Character.Humanoid.PlatformStand = false
        game.Players.LocalPlayer.Character.Animate.Disabled = false
        tpwalking = false



    end





end)


up.MouseButton1Down:connect(function()
    game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame * CFrame.new(0,2,0)

end)


down.MouseButton1Down:connect(function()

    game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame * CFrame.new(0,-2,0)

end)


game:GetService("Players").LocalPlayer.CharacterAdded:Connect(function(char)
    wait(0.7)
    game.Players.LocalPlayer.Character.Humanoid.PlatformStand = false
    game.Players.LocalPlayer.Character.Animate.Disabled = false

end)


plus.MouseButton1Down:connect(function()
    speeds = speeds + 1
    speed.Text = speeds
    if nowe == true then


    tpwalking = false
    for i = 1, speeds do
        spawn(function()

            local hb = game:GetService("RunService").Heartbeat


            tpwalking = true
            local chr = game.Players.LocalPlayer.Character
            local hum = chr and chr:FindFirstChildWhichIsA("Humanoid")
            while tpwalking and hb:Wait() and chr and hum and hum.Parent do
                if hum.MoveDirection.Magnitude > 0 then
                    chr:TranslateBy(hum.MoveDirection)
                end
            end

        end)
        end
        end
end)
mine.MouseButton1Down:connect(function()
    if speeds == 1 then
        speed.Text = 'can not be less than 1'
        wait(1)
        speed.Text = speeds
    else
    speeds = speeds - 1
        speed.Text = speeds
        if nowe == true then
    tpwalking = false
    for i = 1, speeds do
        spawn(function()

            local hb = game:GetService("RunService").Heartbeat


            tpwalking = true
            local chr = game.Players.LocalPlayer.Character
            local hum = chr and chr:FindFirstChildWhichIsA("Humanoid")
            while tpwalking and hb:Wait() and chr and hum and hum.Parent do
                if hum.MoveDirection.Magnitude > 0 then
                    chr:TranslateBy(hum.MoveDirection)
                end
            end

        end)
        end
        end
        end
end)
   -- The function that takes place when the button is pressed
   end,
})
local TeleportTab = Window:CreateTab("Teleport,Fling,Kill(fe)", 4483362458)

local TargetTPPlayerInput = TeleportTab:CreateInput({
    Name = "Target Player",
    CurrentValue = "",
    PlaceholderText = "Enter Player Name",
    RemoveTextAfterFocusLost = false,
    Flag = "TargetTPPlayerInput",
    Callback = function(Text)
        getgenv().targetTPPlayerName = Text
    end,
})

local TeleportButton = TeleportTab:CreateButton({
    Name = "Teleport To Player",
    Callback = function()
        local targetName = getgenv().targetTPPlayerName
        if targetName and targetName ~= "" then
            local Players = game:GetService("Players")
            local targetPlayer = Players:FindFirstChild(targetName)
            local localPlayer = Players.LocalPlayer

            if targetPlayer and targetPlayer ~= localPlayer then
                local targetCharacter = targetPlayer.Character
                local localCharacter = localPlayer.Character

                if targetCharacter and targetCharacter:FindFirstChild("HumanoidRootPart") and
                   localCharacter and localCharacter:FindFirstChild("HumanoidRootPart") then
                    localCharacter.HumanoidRootPart.CFrame = targetCharacter.HumanoidRootPart.CFrame
                    Rayfield:Notify({
                        Title = "Teleport",
                        Content = "Teleported to " .. targetPlayer.Name .. ".",
                        Duration = 3,
                        Type = "Success"
                    })
                    print("Teleported to player: " .. targetPlayer.Name)
                else
                    Rayfield:Notify({
                        Title = "Teleport Error",
                        Content = "Could not teleport. Target or local player character/root part not found.",
                        Duration = 3,
                        Type = "Error"
                    })
                    warn("Could not teleport. Target or local player character/root part not found.")
                end
            elseif targetPlayer == localPlayer then
                Rayfield:Notify({
                    Title = "Teleport Error",
                    Content = "Cannot teleport to yourself.",
                    Duration = 3,
                    Type = "Error"
                })
                warn("Cannot teleport to yourself.")
            else
                Rayfield:Notify({
                    Title = "Teleport Error",
                    Content = "Player '" .. targetName .. "' not found.",
                    Duration = 3,
                    Type = "Error"
                })
                warn("Player '" .. targetName .. "' not found.")
            end
        else
            Rayfield:Notify({
                Title = "Teleport Error",
                Content = "Please enter a player name to teleport to.",
                Duration = 3,
                Type = "Error"
            })
            warn("Please enter a player name to teleport to.")
        end
    end,
})

-- Fling Player Tab (New)


local TargetFlingPlayerInput = TeleportTab:CreateInput({
    Name = "Target Player to Fling",
    CurrentValue = "",
    PlaceholderText = "Enter Player Name",
    RemoveTextAfterFocusLost = false,
    Flag = "TargetFlingPlayerInput",
    Callback = function(Text)
        getgenv().targetFlingPlayerName = Text
    end,
})

local FlingButton = TeleportTab:CreateButton({
    Name = "Fling Player",
    Callback = function()
        local targetName = getgenv().targetFlingPlayerName
        if targetName and targetName ~= "" then
            local Players = game:GetService("Players")
            local targetPlayer = Players:FindFirstChild(targetName)
            local localPlayer = Players.LocalPlayer

            if targetPlayer and targetPlayer ~= localPlayer then
                local targetCharacter = targetPlayer.Character
                if targetCharacter and targetCharacter:FindFirstChild("HumanoidRootPart") then
                    local function gplr(String)
                        local Found = {}
                        local strl = String:lower()
                        if strl == "all" then
                            for i,v in pairs(game:FindService("Players"):GetPlayers()) do
                                table.insert(Found,v)
                            end
                        elseif strl == "others" then
                            for i,v in pairs(game:FindService("Players"):GetPlayers()) do
                                if v.Name ~= localPlayer.Name then
                                    table.insert(Found,v)
                                end
                            end
                        elseif strl == "me" then
                            for i,v in pairs(game:FindService("Players"):GetPlayers()) do
                                if v.Name == localPlayer.Name then
                                    table.insert(Found,v)
                                end
                            end
                        else
                            for i,v in pairs(game:FindService("Players"):GetPlayers()) do
                                if v.Name:lower():sub(1, #String) == String:lower() then
                                    table.insert(Found,v)
                                end
                            end
                        end
                        return Found
                    end

                    local Target = gplr(targetName)[1] -- Get the first matching player
                    if Target then
                        local Thrust = Instance.new('BodyThrust', localPlayer.Character:FindFirstChild("HumanoidRootPart"))
                        if Thrust then
                            Thrust.Force = Vector3.new(9999,9999,9999)
                            Thrust.Name = "YeetForce"
                            repeat
                                if localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart") and
                                   Target.Character and Target.Character:FindFirstChild("HumanoidRootPart") then
                                    localPlayer.Character.HumanoidRootPart.CFrame = Target.Character.HumanoidRootPart.CFrame
                                    Thrust.Location = Target.Character.HumanoidRootPart.Position
                                    game:GetService("RunService").Heartbeat:Wait()
                                else
                                    break -- Stop if characters or root parts are missing
                                end
                            until not Target.Character:FindFirstChild("Head")
                            Thrust:Destroy() -- Clean up the BodyThrust
                            Rayfield:Notify({
                                Title = "Fling",
                                Content = "Attempted to fling player: " .. Target.Name .. ".",
                                Duration = 3,
                                Type = "Warning" -- Client-side teleportation for fling effect
                            })
                            print("Attempted to fling player: " .. Target.Name)
                        else
                            Rayfield:Notify({
                                Title = "Fling Error",
                                Content = "Local player's HumanoidRootPart not found for BodyThrust.",
                                Duration = 3,
                                Type = "Error"
                            })
                            warn("Local player's HumanoidRootPart not found for BodyThrust.")
                        end
                    else
                        Rayfield:Notify({
                            Title = "Fling Error",
                            Content = "Player '" .. targetName .. "' not found.",
                            Duration = 3,
                            Type = "Error"
                        })
                        warn("Player '" .. targetName .. "' not found.")
                    end
                else
                    Rayfield:Notify({
                        Title = "Fling Error",
                        Content = "Target player's character or HumanoidRootPart not found.",
                        Duration = 3,
                        Type = "Error"
                    })
                    warn("Target player's character or HumanoidRootPart not found.")
                end
            else
                Rayfield:Notify({
                    Title = "Fling Error",
                    Content = "Player '" .. targetName .. "' not found.",
                    Duration = 3,
                    Type = "Error"
                })
                warn("Player '" .. targetName .. "' not found.")
            end
        else
            Rayfield:Notify({
                Title = "Fling Error",
                Content = "Please enter a player name to fling.",
                Duration = 3,
                Type = "Error"
            })
            warn("Please enter a player name to fling.")
        end
    end,
})
local TargetKillPlayerInput = TeleportTab:CreateInput({
    Name = "Player to Kill",
    CurrentValue = "",
    PlaceholderText = "Enter Player Name",
    RemoveTextAfterFocusLost = false,
    Flag = "TargetKillPlayerInput",
    Callback = function(Text)
        getgenv().targetKillPlayerName = Text
    end,
})
local KillButton = TeleportTab:CreateButton({
    Name = "Kill Player",
    Callback = function()
        local targetName = getgenv().targetKillPlayerName
        if targetName and targetName ~= "" then
            local Players = game:GetService("Players")
            local targetPlayer = Players:FindFirstChild(targetName)
            local localPlayer = Players.LocalPlayer

            if targetPlayer and targetPlayer ~= localPlayer then
                local targetCharacter = targetPlayer.Character
                if targetCharacter and targetCharacter:FindFirstChild("Humanoid") then
                    local humanoid = targetCharacter:FindFirstChild("Humanoid")
                    if humanoid.Health > 0 then
                        humanoid.Health = 0
                        Rayfield:Notify({
                            Title = "Kill",
                            Content = "Attempted to kill player: " .. targetPlayer.Name .. ".",
                            Duration = 3,
                            Type = "Warning" -- Client-side health manipulation
                        })
                        print("Attempted to kill player: " .. targetPlayer.Name)
                    else
                        Rayfield:Notify({
                            Title = "Kill Info",
                            Content = "Player " .. targetPlayer.Name .. " is already dead.",
                            Duration = 3,
                            Type = "Info"
                        })
                        warn("Player " .. targetPlayer.Name .. " is already dead.")
                    end
                else
                    Rayfield:Notify({
                        Title = "Kill Error",
                        Content = "Target player's character or Humanoid not found.",
                        Duration = 3,
                        Type = "Error"
                    })
                    warn("Target player's character or Humanoid not found.")
                end
            else
                Rayfield:Notify({
                    Title = "Kill Error",
                    Content = "Player '" .. targetName .. "' not found.",
                    Duration = 3,
                    Type = "Error"
                })
                warn("Player '" .. targetName .. "' not found.")
            end
        else
            Rayfield:Notify({
                Title = "Kill Error",
                Content = "Please enter a player name to kill.",
                Duration = 3,
                Type = "Error"
            })
            warn("Please enter a player name to kill.")
        end
    end,
})
